/*************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 * <p>
 *  Copyright 2025 Adobe
 *  All Rights Reserved.
 * <p>
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe and its suppliers, if any. The intellectual
 * and technical concepts contained herein are proprietary to Adobe
 * and its suppliers and are protected by all applicable intellectual
 * property laws, including trade secret and copyright laws.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe.
 * <p>
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech)
 * using custom templates. Generator configuration can be found in the /generator directory.
 * <p>
 * Do not edit this file manually!
 **************************************************************************/
package com.adobe.aco.client;

import com.adobe.aco.model.FeedMetadata;
import com.adobe.aco.model.FeedMetadataDelete;
import com.adobe.aco.model.FeedMetadataUpdate;
import com.adobe.aco.model.FeedPricebook;
import com.adobe.aco.model.FeedPricebookDelete;
import com.adobe.aco.model.FeedPrices;
import com.adobe.aco.model.FeedPricesDelete;
import com.adobe.aco.model.FeedPricesUpdate;
import com.adobe.aco.model.FeedProduct;
import com.adobe.aco.model.FeedProductDelete;
import com.adobe.aco.model.FeedProductUpdate;
import com.adobe.aco.model.ProcessFeedResponse;
import java.util.List;

public interface Client {
    /**
     * Create product attribute metadata To ensure product data is indexed for discovery, create or
     * replace existing product attribute metadata resources before creating products. For each
     * Commerce project, you must define metadata for the following attributes for each scope
     * (`locale`): - `sku` - `name` - `description` - `shortDescription` - `price` Also, you can
     * define metadata for custom attributes. When creating product attribute metadata: - Each
     * product attribute requires a unique `code` and `scope`. - Use the `dataType` field to define
     * the data type for the product attribute. - Use the `visibleIn` field to define where the
     * product attribute is displayed on the storefront. - Use the `filterable`, `sortable`, and
     * `searchable` fields to define how the product attribute is used for filtering, sorting, and
     * searching. - Use the `searchWeight` field to define the search weight for the product
     * attribute. - Use the `searchTypes` field to define the search type for the product attribute.
     * To update existing product attribute metadata, use the update operation.
     *
     * @param data payload of type List<FeedMetadata>
     * @return ProcessFeedResponse indicating the result of the ingestion.
     * @throws RuntimeException if the API request fails
     */
    ProcessFeedResponse createProductMetadata(List<FeedMetadata> data);
    /**
     * Delete product attributes metadata Remove product attribute metadata resources from the
     * catalog data.
     *
     * @param data payload of type List<FeedMetadataDelete>
     * @return ProcessFeedResponse indicating the result of the ingestion.
     * @throws RuntimeException if the API request fails
     */
    ProcessFeedResponse deleteProductMetadata(List<FeedMetadataDelete> data);
    /**
     * Update product attribute metadata Update existing product attribute metadata with new values.
     * When the update is processed, the merge strategy is used to apply changes to `scalar` and
     * `object` type fields. The replace strategy is used to apply changes for fields in an `array`.
     *
     * @param data payload of type List<FeedMetadataUpdate>
     * @return ProcessFeedResponse indicating the result of the ingestion.
     * @throws RuntimeException if the API request fails
     */
    ProcessFeedResponse updateProductMetadata(List<FeedMetadataUpdate> data);
    /**
     * Create price books Create or replace existing price books. Use the [update price books
     * operation](#operation/updatePriceBooks) to modify values for existing price books.
     * <strong>Note:</strong> After you assign a `parentId` to a price book, you cannot change the
     * parentId value using the update operation. If you want to define a different parent-child
     * relationship, delete the child price book and create a new one with the desired parent-child
     * relationship.
     *
     * @param data payload of type List<FeedPricebook>
     * @return ProcessFeedResponse indicating the result of the ingestion.
     * @throws RuntimeException if the API request fails
     */
    ProcessFeedResponse createPriceBooks(List<FeedPricebook> data);
    /**
     * Delete price books When you delete a price book, all its child price books and all prices
     * assigned to the `priceBookId` and its children are also deleted. If a price book is deleted
     * by mistake, you have up to one week to restore the deleted price books and their associated
     * prices. Restoring is done by recreating the top-level parent price book that was deleted,
     * using the same payload submitted in the original create price book request. The state of the
     * price books and prices are restored to the status and price values assigned when the price
     * book was deleted.
     *
     * @param data payload of type List<FeedPricebookDelete>
     * @return ProcessFeedResponse indicating the result of the ingestion.
     * @throws RuntimeException if the API request fails
     */
    ProcessFeedResponse deletePriceBooks(List<FeedPricebookDelete> data);
    /**
     * Update price books Change the name of a base or child price book, or change the currency
     * assigned to the base price book. When you submit the update request for a child price book,
     * include the correct `parentId`. If the request includes a different `parentId`, the value is
     * ignored.
     *
     * @param data payload of type List<FeedPricebook>
     * @return ProcessFeedResponse indicating the result of the ingestion.
     * @throws RuntimeException if the API request fails
     */
    ProcessFeedResponse updatePriceBooks(List<FeedPricebook> data);
    /**
     * Create prices Create or replace existing product prices.
     *
     * <h3>Configurable Products</h3>
     *
     * Because configurable product price is calculated based on the price of the selected product
     * variant, you don't need to send price data for configurable product skus. Sending price data
     * for these skus can cause incorrect price calculations.
     *
     * @param data payload of type List<FeedPrices>
     * @return ProcessFeedResponse indicating the result of the ingestion.
     * @throws RuntimeException if the API request fails
     */
    ProcessFeedResponse createPrices(List<FeedPrices> data);
    /**
     * Delete prices Delete existing product prices
     *
     * @param data payload of type List<FeedPricesDelete>
     * @return ProcessFeedResponse indicating the result of the ingestion.
     * @throws RuntimeException if the API request fails
     */
    ProcessFeedResponse deletePrices(List<FeedPricesDelete> data);
    /**
     * Update prices Change existing product prices When the update is processed, the merge strategy
     * is used to apply changes to `scalar` and `object` type fields. The replace strategy is used
     * to apply changes for fields in an `array`.
     *
     * @param data payload of type List<FeedPricesUpdate>
     * @return ProcessFeedResponse indicating the result of the ingestion.
     * @throws RuntimeException if the API request fails
     */
    ProcessFeedResponse updatePrices(List<FeedPricesUpdate> data);
    /**
     * Create or replace products You can create different types of products, such as simple
     * products and configurable products. When creating products: - Each product requires a unique
     * SKU identifier. - Products must have a defined scope, for example `locale`. - Add values for
     * the required `name`, `slug`, and `status` fields. - Define optional fields such as
     * descriptions, images, and custom attributes as needed. - Use the `links` field to define
     * relationships between products, such as linking a product variant to its parent configurable
     * product. - You can create multiple products in a single request, and also create product
     * variants for configurable products in the same request.
     *
     * <h3 id=\"simpleProducts\">Simple Products</h3>
     *
     * Create products or replace existing products with specified `sku` and `scope` values. If a
     * product with the same data exists with the same SKU and scope, the product update request is
     * ignored. Use the <strong>[update operation](#operation/updateProducts)</strong> to modify
     * values for an existing product.
     *
     * <h3>Configurable Products</h3>
     *
     * A configurable product is a parent product that allows customers to select from multiple
     * predefined attributes such as color, size, and material. Each unique combination of these
     * attribute values (for example, `color=green`, `size=large`) represents a product variant.
     * Each variant is treated as a distinct child product with its own SKU, price, and inventory.
     * These variants are stored as separate entities in the database and linked to the parent
     * configurable product. The configurable product itself acts as a container or abstraction
     * layer, enabling a unified frontend experience while maintaining granular control over each
     * variant on the backend. To create a configurable product, you need the following: *
     * <strong>Product attributes</strong>â€”<a href=\"#operation/createProductMetadata\">Create
     * product attributes</a> (for example, \"color\", \"size\") that will be used to differentiate
     * product variants. These attributes must be registered in the system before they can be
     * referenced in product definitions. * <strong>Configurable product</strong>â€”Define the parent
     * product and include a
     * [configurations](#operation/createProducts!path=configurations&t=request) array that
     * specifies the selectable options and maps each option to a set of possible values. Each value
     * must include a
     * [variantReferenceId](#operation/createProducts!path=configurations/values/variantReferenceId&t=request),
     * which links to a specific variant. * <strong>Product variants</strong>â€”Define a product
     * variant for each valid combination of attribute values. Each variant must: * Include relevant
     * attribute values in an [attributes](#operation/createProducts!path=attributes&t=request)
     * array. * Reference the parent configurable product using variantReferenceId. * Include a
     * [links](#operation/createProducts!path=links&t=request) array with a link of type
     * `VARIANT_OF` pointing to the configurable product. For example:
     *
     * <pre>
     *    {     \"sku\": \"pants-red-32\",     \"attributes\": [       {         \"code\": \"color\",         \"type\": \"STRING\",         \"values\": [\"Red\"],         \"variantReferenceId\": \"pants-color-red\"       }     ],     \"links\": [       {         \"type\": \"VARIANT_OF\",         \"sku\": \"pants\"       }     ]   }
     * </pre>
     *
     * Each product variant links back to the configurable product through its `variantReferenceId`,
     * which corresponds to specific `configurations[].values[].variantReferenceId` in the
     * configurable product. To unassign a product variant from a configurable product, do one of
     * the following: - Use [Delete Product API](#operation/deleteProducts) to delete the product
     * variant. - Use [Update Product API](#operation/updateProducts) to set the
     * [\"variantReferenceId\"](#operation/createProducts!path=attributes/variantReferenceId&t=request)
     * to `null` and unassign the product variant from the configurable product by removing the
     * [\"links\"](#operation/createProducts!path=links&t=request) association.
     *
     * <h3>Bundle Products</h3>
     *
     * A bundle product combines several simple products into one sellable unit. Items within the
     * bundle can be categorized into logical groups like `tops`, `bottoms`, and `accessories`. Each
     * group can have multiple items, and shoppers can select items from each group to create a
     * customized bundle. To create a bundle product, you need the following: * <strong>Bundle
     * product</strong>â€”[Define the parent product](#operation/createProducts) and include a
     * [bundles](#operation/createProducts!path=bundles) array that specifies the groups and items
     * included in the bundle. Each group must define: * `group` - Name of the group (for example,
     * \"tops\", \"bottoms\") * `required` - Whether a selection from this group is mandatory *
     * `multiSelect` - Whether multiple items can be selected * `items` - List of products that can
     * be selected from this group * <strong>Simple products</strong>â€”Define each simple product to
     * include in the bundle. Each product must: * Include a
     * [links](#operation/createProducts!path=links) array with a link of type `IN_BUNDLE` pointing
     * to the bundle product * Be created separately using the [create product
     * API](#operation/createProducts) <strong>Note:</strong> A simple product can be included only
     * once in each bundle. If the same item is specified in multiple groups, the API returns a
     * `Duplicate SKU found in bundle items` error. To update a bundle product, do one of the
     * following: * Use the [Update products API](#operation/updateProducts) to modify the groups
     * and items in the bundle * Use the [Delete products API](#operation/deleteProducts) to remove
     * items from the bundle
     *
     * @param data payload of type List<FeedProduct>
     * @return ProcessFeedResponse indicating the result of the ingestion.
     * @throws RuntimeException if the API request fails
     */
    ProcessFeedResponse createProducts(List<FeedProduct> data);
    /**
     * Delete products Delete products with specified `sku`` and `scope`` values
     *
     * @param data payload of type List<FeedProductDelete>
     * @return ProcessFeedResponse indicating the result of the ingestion.
     * @throws RuntimeException if the API request fails
     */
    ProcessFeedResponse deleteProducts(List<FeedProductDelete> data);
    /**
     * Update products Update products with specified `sku` and `scope` values to replace existing
     * field data with the data supplied in the request. When the update is processed, the merge
     * strategy is used to apply changes to `scalar` and `object` type fields. The replace strategy
     * is used to apply changes for fields in an `array`.
     *
     * @param data payload of type List<FeedProductUpdate>
     * @return ProcessFeedResponse indicating the result of the ingestion.
     * @throws RuntimeException if the API request fails
     */
    ProcessFeedResponse updateProducts(List<FeedProductUpdate> data);
}
